---
layout: post
title:  "Apprendere le basi di Haskell in 10 minuti"
date:   2012-01-02 22:45:33
categories: update
tags: [haskell]
image:
  feature: so-simple-sample-image-1.jpg
  credit: Michael Rose
  creditlink: http://mademistakes.com
comments: false
share: true
---

Contenuti 

1. Panoramica
2. Espressioni semplici
3. La console
4. Tipi semplici
5. Dati strutturati
6. Definizione di funzioni
7. Convenient syntax
8. Usare le librerie
9. Argomenti che non rientrano nel limite di 10 minuti

#1 Panoramica
Haskell è un linguaggio funzionale (ogni cosa è fatta con chiamate a funzione), tipato staticamente, tipato implicitamente (i tipi sono controllati dal compilatore, ma non è necessario che siano dichiarati), lazy (nulla è fatto finché non è necessario). 
Il suo parente più vicino e popolare è probabilmente la famiglia dei linguaggi ML
(che non sono tuttavia comunque linguaggi lazy).

Il compilatore Haskell più comune è GHC. Puoi scaricare GHC da http://www.haskell.org/ghc/download.html . I binari di GHC sono disponibili per GNU/Linux, FreeBSD, MacOS,Windows e Solaris. 
Una volta installato GHC, sia hanno a disposizione due programmi : ghc e ghci. 
Il primo compila librerie o applicazioni Haskell in codice binario.  Il secondo è un interprete che ti permette di scrivere codice Haskell e ottenere un feedback immediato.

#2 Espressioni semplici
È possibile digitare la maggior parte delle espressioni matematiche direttamente in ghci e ottenere una risposta.Prelude> è il prompt di default di GHCi.


Prelude> 3 * 5
 15
 Prelude> 4 ^ 2 - 1
 15
 Prelude> (1 - 5)^(3 * 2 - 4)
 16

Le stringhe sono tra “doppi apici” e si possono concatenare tra loro con l’operatore 
++
.
Prelude> "Hello"
 "Hello"
 Prelude> "Hello" ++ ", Haskell"
 "Hello, Haskell"

La chiamata a funzioni è ottenuta mettendo gli argomenti direttamente dopo il nome di funzione. Non ci sono parentesi come parte della chiamata a funzione:

Prelude> succ 5
 6
 Prelude> truncate 6.59
 6
 Prelude> round 6.59
 7
 Prelude> sqrt 2
 1.4142135623730951
 Prelude> not (5 < 3)
 True
 Prelude> gcd 21 14
 7

#3 La console
Operazioni di I/O possono essere usate per leggere e scrivere dalla console. Alcune fra le più comuni includono:

Prelude> putStrLn "Hello, Haskell"
 Hello, Haskell
 Prelude> putStr "No newline"
 No newline
 Prelude> print (5 + 4)
 9
 Prelude> print (1 < 2)
 True

Le funzioni putStr e putStrLn mandano le stringhe in output sul terminale. 
La funzione print manda in output qualsiasi tipo di valore. (Se si fa 
print di una stringa, avrà virgolette intorno ad essa).

Se necessiti di operazioni di I/O multiple in una espressione, puoi usare
do block. 

Le azioni sono separate da ;.
Prelude> do { putStr "2 + 2 = " ; print (2 + 2) }
 2 + 2 = 4
 Prelude> do { putStrLn "ABCDE" ; putStrLn "12345" }
 ABCDE
 12345

Lettura può essere fatto con getLine (che restituisce un String) o  readLn  (che restituisce qualsiasi tipo di valore che si desidera). 
Il simbolo <- è utilizzato per assegnare un nome al risultato di una operazione di I/O.

Prelude> do { n <- readLn ; print (n^2) }
 4
 16

(Il 4 era di ingresso, il 16 era un risultato.)
Vi è in realtà un altro modo per scrivere do blocks. 
Se si escludono le parentesi graffe e punti e virgola, l’indentazione del codice diventa significativa. 
Questo non funziona così bene in ghci, ma prova a mettere il file in un file di origine (ad esempio, Test.hs) e costruirlo.

main = do putStrLn "What is 2 + 2?"
          x <- readLn
          if x == 4
              then putStrLn "You're right!"
              else putStrLn "You're wrong!"

È possibile creare con GHC - Test.hs e lanciarlo, il risultato sarà chiamato test. (In Windows, Test.exe) 

Si ha un if expression as a bonus. Il primo non-spazio carattere dopo do è speciale. In questo caso, è il p da putStrLn.Ogni linea che inizia nella colonna stessa p è un altro statement in do block. 
Se si indenta il codice ancora è parte del precedente statement. Se indenti meno è la fine di do block. 
Questo sistema è chiamato "layout" e Haskell lo utilizza per evitare di farvi mette in conto terminatori e parentesi per tutto il tempo. (le parole then e else devono essere indentate per questo motivo: se hanno iniziato nella stessa colonna, sarebbero bilancio separato, che è sbagliato.)

(Nota: non indentare con tabulazioni se si sta utilizzando il layout ,tecnicamente funziona anche se i tab sono 8, ma è una cattiva idea Inoltre, non utilizzare i caratteri proporzionali - che a quanto pare alcune persone lo fanno, anche se.. programmazione!)

#4 Tipi semplici
Finora non una dichiarazione di tipo singolo è stato menzionato. Questo perché Haskell fa l'inferenza dei tipi. In genere non c'è bisogno di dichiarare i tipi a meno che non si desideri. Se si vuole dichiarare i tipi, è possibile utilizzare

::
per farlo.
Prelude> 5 :: Int
 5
 Prelude> 5 :: Double
 5.0

Tipi (e tipi classe, discussi più avanti) devono sempre iniziare con lettere maiuscole in Haskell. Variabili iniziano sempre con lettere minuscole.

Questa è una regola del linguaggio, non una convenzione per i nomi.
Si può anche chiedere che tipo ghci ha scelto per qualcosa. Questo è utile perché in genere non è necessario dichiarare i tipi.
Prelude> :t True
 True :: Bool
 Prelude> :t 'X'
 'X' :: Char
 Prelude> :t "Hello, Haskell"
 "Hello, Haskell" :: [Char]

(Nel caso in cui avete notato, [Char] è un altro modo di dire String).
Le cose si fanno più interessanti per i numeri.

Prelude> :t 42
 42 :: (Num t) => t
 Prelude> :t 42.0
 42.0 :: (Fractional t) => t
 Prelude> :t gcd 15 20
 gcd 15 20 :: (Integral t) => t

Questi tipi di usare "classi di tipo". Significano:
42 può essere utilizzato come un qualsiasi tipo numerico. (È per questo che sono stato in grado di dichiarare 
5 sia come Int o un Double prima.)
42.0 può essere qualsiasi tipo frazionario, ma non un tipo integer.
gcd 15 20
 (che è una chiamata di funzione, tra l'altro) può essere qualsiasi tipo integer, ma non del tipo frazionario.
Ci sono cinque tipi di dati numerici in Haskell "Prelude" (la parte delle librerie si ottiene senza dover importare nulla):.
Int è un numero intero di almeno 30 bit di precisione.
Integer è un numero intero con precisione illimitata.
Float è un singolo numero in virgola mobile di precisione.
Double è un doppio numero in virgola mobile di precisione.
Rational è un tipo di frazione, senza alcun errore di arrotondamento.
Tutti e cinque sono istanze della Num tipo di classe. Le prime due sono le istanze di Integral, E gli ultimi tre sono instances di Fractional.
Mettendo tutto insieme,

Prelude> gcd 42 35 :: Int
 7
 Prelude> gcd 42 35 :: Double
 
 <interactive>:1:0:
     No instance for (Integral Double)

L'ultimo tipo che vale la pena menzionare è (), pronunciato "Unit" ha un solo valore, scritto anche come () e pronunciato "unit". 
Prelude> ()
 ()
 Prelude> :t ()
 () :: ()

Si può pensare a questo come simile alla parola chiave void in lingue di famiglia C. È possibile restituire () da un I / O di azione se non si vuole restituire qualcosa..

#5 Dati strutturati
I tipi di dati di base possono essere facilmente combinati in due modi: liste, che vanno in [parentesi quadre] e tuple, che vanno in (parentesi).
Elenchi vengono utilizzati per contenere più valori dello stesso tipo.

Prelude> [1, 2, 3]
 [1,2,3]
 Prelude> [1 .. 5]
 [1,2,3,4,5]
 Prelude> [1, 3 .. 10]
 [1,3,5,7,9]
 Prelude> [True, False, True]
 [True,False,True]

Le stringhe sono solo liste di caratteri.
Prelude> ['H', 'e', 'l', 'l', 'o']
 "Hello"

Il : operatore aggiunge un elemento all'inizio di una lista. (E 'la versione Haskell della funzione cons nella famiglia dei linguaggi Lisp )
Prelude> 'C' : ['H', 'e', 'l', 'l', 'o']
 "CHello"

Le tuple in possesso di un numero fisso di valori, che può avere diversi tipi.
Prelude> (1, True)
 (1,True)
 Prelude> zip [1 .. 5] ['a' .. 'e']
 [(1,'a'),(2,'b'),(3,'c'),(4,'d'),(5,'e')]

L'esempio utilizzato per ultimo zip , Una funzione di libreria che trasforma due liste in una lista di tuple.
I tipi sono probabilmente quello che vi aspettereste.

Prelude> :t ['a' .. 'c']
 ['a' .. 'c'] :: [Char]
 Prelude> :t [('x', True), ('y', False)]
 [('x', True), ('y', False)] :: [(Char, Bool)]

Le liste sono molto usati in Haskell. Ci sono diverse funzioni che fanno belle cose con loro.
Prelude> [1 .. 5]
 [1,2,3,4,5]
 Prelude> map (+ 2) [1 .. 5]
 [3,4,5,6,7]
 Prelude> filter (> 2) [1 .. 5]
 [3,4,5]

Ci sono due utili funzioni di coppie ordinate (tuple di due elementi):
Prelude> fst (1, 2)
 1
 Prelude> snd (1, 2)
 2
 Prelude> map fst [(1, 2), (3, 4), (5, 6)]
 [1,3,5]

Vedi anche come lavorare sulle liste

#6 Definizione di funzioni
Abbiamo scritto una definizione di un'operazione I/O precedente, chiamato
main:
main = do putStrLn "What is 2 + 2?"
          x <- readLn
          if x == 4
              then putStrLn "You're right!"
              else putStrLn "You're wrong!"
Ora, cerchiamo di completarlo da scrivere effettivamente una definizione di funzione e lo chiamano factorial. Aggiungiamo anche un module header che è una buona forma.

module Main where
 
factorial n = if n == 0 then 1 else n * factorial (n - 1)
 
main = do putStrLn "What is 5! ?"
          x <- readLn
          if x == factorial 5
              then putStrLn "You're right!"
              else putStrLn "You're wrong!"

Build again with ghc --make Test.hs. And,
$ ./Test
 What is 5! ?
 120
 You're right!

C'è una funzione. Proprio come le funzioni incorporate, può essere chiamato come
fattoriale 5 senza bisogno di parentesi.
Ora chiedere ghci per il tipo.

$ ghci Test.hs
 << GHCi banner >>
 Ok, modules loaded: Main.
 Prelude Main> :t factorial
 factorial :: (Num a) => a -> a

Tipo di funzione sono scritti con il tipo di argomento, quindi -> ,quindi il risultato tipo. (Questo ha anche il tipo di classe Num .)
Fattoriale può essere semplificata scrivendo con analisi di casi.
factorial 0 = 1
factorial n = n * factorial (n - 1)
# 7 Convenient syntax - Sintassi conveniente
Un paio di pezzi in più di sintassi sono utili.
secsToWeeks secs = let perMinute = 60
                       perHour   = 60 * perMinute
                       perDay    = 24 * perHour
                       perWeek   =  7 * perDay
                   in  secs / perWeek
The let espressione definisce i nomi temporanei. (Questo è usare il layout di nuovo. È possibile utilizzare le parentesi graffe {}, e separare i nomi con un punto e virgola, se si preferisce.)
classify age = case age of 0 -> "newborn"
                           1 -> "infant"
                           2 -> "toddler"
                           _ -> "senior citizen"
L’espressione case ha un multi-way ramo. L'etichetta speciale _  significa "tutto il resto"..

#8 Usare le librerie
Le cose finora utilizzato in questo tutorial fa parte di Preludio, che è l'insieme delle funzioni Haskell che sono sempre presenti in qualsiasi programma.
La migliore strada da qui a diventare un programmatore molto produttivo Haskell (a parte la pratica!) Sta diventando familiare con altre librerie che fanno le cose che avete bisogno. Documentazione sulle librerie standard è raggiungibile all’indirizzo
http://haskell.org/ghc/docs/latest/html/libraries/. 
Ci sono moduli lì con:
Utili strutture dati
Programmazione concorrente e parallela
Graphics E GUI librerie
Networking, POSIX, e altre funzioni a livello di sistema. 
Due framework di test, QuickCheck e HUnit
Regular expressions e parser predittivi
Altro..

module Main where
 
import qualified Data.Map as M
 
errorsPerLine = M.fromList
    [ ("Chris", 472), ("Don", 100), ("Simon", -5) ]
 
main = do putStrLn "Who are you?"
          name <- getLine
          case M.lookup name errorsPerLine of
              Nothing -> putStrLn "I don't know you"
              Just n  -> do putStr "Errors per line: "
                            print n
import di usare codice da  Data.Map e che sarà preceduto da M. (Questo è necessario perché alcune delle funzioni hanno gli stessi nomi come funzioni del preludio. Maggior parte delle biblioteche non è necessario la parte  as )

Se si desidera qualcosa che non è nella libreria standard, prova a guardare http://hackage.haskell.org/packages/hackage.html o applicazioni di questa pagina wiki e biblioteche. Si tratta di una raccolta di molte librerie diverse scritte da un sacco di persone per Haskell. Una volta che hai una libreria, estrarre e passare in quella directory e fare questo:

runhaskell Setup configure
runhaskell Setup build
runhaskell Setup install

Su un sistema UNIX, potrebbe essere necessario essere root per l'ultima parte.
#9 Argomenti che non rientrano nel limite di 10 minuti
Advanced data types
Arithmetic lists
List comprehensions
Type synonyms
data vs newtype (and here)
Type classes and instances
Advanced syntax
Operators
(+) and `foo`
Fixity declarations
Advanced functions
Currying
Lambda abstractions
Sections
Monads
File I/O
Reading files
Writing Files













OLD


**BPEL** *(Business Process Execution Language)* è un linguaggio basato su XML costruito per descrivere formalmente i processi commerciali ed industriali in modo da permettere una suddivisione dei compiti tra attori diversi, in pratica permette di definire processi di workflow tramite XML.
Normalmente un'applicazione BPEL viene invocata come servizio web ed interagisce con il mondo esterno esclusivamente invocando altri servizi web. 
Rappresenta una forma di coordinazione di servizi Web, permettendo di comporli in maniera ricorsiva. 
L'ambiente runtime all'interno del quale viene eseguito il processo è detto motore BPEL.


